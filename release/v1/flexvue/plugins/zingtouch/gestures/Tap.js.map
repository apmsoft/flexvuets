{"version":3,"file":"Tap.js","names":["Gesture","util","DEFAULT_MIN_DELAY_MS","DEFAULT_MAX_DELAY_MS","DEFAULT_INPUTS","DEFAULT_MOVE_PX_TOLERANCE","Tap","constructor","options","type","minDelay","maxDelay","numInputs","tolerance","onEnd","start","inputs","length","forEach","input","progress","getGestureProgress","getId","Date","getTime","move","state","element","i","getCurrentEventType","current","previous","isWithin","x","y","resetProgress","end","startTime","Number","MAX_VALUE","interval","timing"],"sources":["Tap.js"],"sourcesContent":["/**\n * @file Tap.js\n * Contains the Tap class\n */\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\nconst DEFAULT_MIN_DELAY_MS = 0;\nconst DEFAULT_MAX_DELAY_MS = 300;\nconst DEFAULT_INPUTS = 1;\nconst DEFAULT_MOVE_PX_TOLERANCE = 10;\n/**\n * A Tap is defined as a touchstart to touchend event in quick succession.\n * @class Tap\n */\nclass Tap extends Gesture {\n    /**\n     * Constructor function for the Tap class.\n     * @param {Object} [options] - The options object.\n     * @param {Number} [options.minDelay=0] - The minimum delay between a\n     * touchstart and touchend can be configured in milliseconds.\n     * @param {Number} [options.maxDelay=300] - The maximum delay between a\n     * touchstart and touchend can be configured in milliseconds.\n     * @param {Number} [options.numInputs=1] - Number of inputs for Tap gesture.\n     * @param {Number} [options.tolerance=10] - The tolerance in pixels\n     *  a user can move.\n     * @param {Function} [options.onStart] - The on start callback\n     * @param {Function} [options.onMove] - The on move callback\n     * @param {Function} [options.onEnd] - The on end callback\n     */\n    constructor(options) {\n        super();\n        /**\n         * The type of the Gesture.\n         * @type {String}\n         */\n        this.type = 'tap';\n        /**\n         * The minimum amount between a touchstart and a touchend can be configured\n         * in milliseconds. The minimum delay starts to count down when the expected\n         * number of inputs are on the screen, and ends when ALL inputs are off the\n         * screen.\n         * @type {Number}\n         */\n        this.minDelay = (options && options.minDelay) ?\n            options.minDelay : DEFAULT_MIN_DELAY_MS;\n        /**\n         * The maximum delay between a touchstart and touchend can be configured in\n         * milliseconds. The maximum delay starts to count down when the expected\n         * number of inputs are on the screen, and ends when ALL inputs are off the\n         * screen.\n         * @type {Number}\n         */\n        this.maxDelay = (options && options.maxDelay) ?\n            options.maxDelay : DEFAULT_MAX_DELAY_MS;\n        /**\n         * The number of inputs to trigger a Tap can be variable,\n         * and the maximum number being a factor of the browser.\n         * @type {Number}\n         */\n        this.numInputs = (options && options.numInputs) ?\n            options.numInputs : DEFAULT_INPUTS;\n        /**\n         * A move tolerance in pixels allows some slop between a user's start to end\n         * events. This allows the Tap gesture to be triggered more easily.\n         * @type {number}\n         */\n        this.tolerance = (options && options.tolerance) ?\n            options.tolerance : DEFAULT_MOVE_PX_TOLERANCE;\n        /**\n         * The on end callback\n         */\n        if (options && options.onEnd && typeof options.onEnd === 'function') {\n            this.onEnd = options.onEnd;\n        }\n    }\n    /* constructor*/\n    /**\n     * Event hook for the start of a gesture. Keeps track of when the inputs\n     * trigger the start event.\n     * @param {Array} inputs - The array of Inputs on the screen.\n     * @return {null} - Tap does not trigger on a start event.\n     */\n    start(inputs) {\n        if (inputs.length === this.numInputs) {\n            inputs.forEach((input) => {\n                let progress = input.getGestureProgress(this.getId());\n                progress.start = new Date().getTime();\n            });\n        }\n        return null;\n    }\n    /* start*/\n    /**\n     * Event hook for the move of a gesture. The Tap event reaches here if the\n     * user starts to move their input before an 'end' event is reached.\n     * @param {Array} inputs - The array of Inputs on the screen.\n     * @param {Object} state - The state object of the current region.\n     * @param {Element} element - The element associated to the binding.\n     * @return {null} - Tap does not trigger on a move event.\n     */\n    move(inputs, state, element) {\n        for (let i = 0; i < inputs.length; i++) {\n            if (inputs[i].getCurrentEventType() === 'move') {\n                let current = inputs[i].current;\n                let previous = inputs[i].previous;\n                if (!util.isWithin(current.x, current.y, previous.x, previous.y, this.tolerance)) {\n                    let type = this.type;\n                    inputs.forEach(function (input) {\n                        input.resetProgress(type);\n                    });\n                    return null;\n                }\n            }\n        }\n        return null;\n    }\n    /* move*/\n    /**\n     * Event hook for the end of a gesture.\n     * Determines if this the tap event can be fired if the delay and tolerance\n     * constraints are met. Also waits for all of the inputs to be off the screen\n     * before determining if the gesture is triggered.\n     * @param {Array} inputs - The array of Inputs on the screen.\n     * @return {null|Object} - null if the gesture is not to be emitted,\n     * Object with information otherwise. Returns the interval time between start\n     * and end events.\n     */\n    end(inputs) {\n        if (inputs.length !== this.numInputs) {\n            return null;\n        }\n        let startTime = Number.MAX_VALUE;\n        for (let i = 0; i < inputs.length; i++) {\n            if (inputs[i].getCurrentEventType() !== 'end') {\n                return null;\n            }\n            let progress = inputs[i].getGestureProgress(this.getId());\n            if (!progress.start) {\n                return null;\n            }\n            // Find the most recent input's startTime\n            if (progress.start < startTime) {\n                startTime = progress.start;\n            }\n        }\n        let interval = new Date().getTime() - startTime;\n        if ((this.minDelay <= interval) && (this.maxDelay >= interval)) {\n            const timing = { interval };\n            if (this.onEnd) {\n                this.onEnd(inputs, timing);\n            }\n            return timing;\n        }\n        else {\n            let type = this.type;\n            inputs.forEach(function (input) {\n                input.resetProgress(type);\n            });\n            return null;\n        }\n    }\n}\nexport default Tap;\n"],"mappings":"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","ignoreList":[]}