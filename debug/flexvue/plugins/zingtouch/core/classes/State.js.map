{"version":3,"file":"State.js","names":["Gesture","Pan","Distance","Rotate","Swipe","Tap","Binding","Input","util","DEFAULT_MOUSE_ID","State","constructor","regionId","inputs","bindings","numGestures","registeredGestures","registerGesture","addBinding","element","gesture","handler","capture","bindOnce","boundGesture","tagName","Error","Object","keys","indexOf","id","assignGestureId","push","addEventListener","getId","retrieveBindingsByElement","filter","b","retrieveBindingsByInitialPos","binding","some","input","isInside","initial","x","y","updateInputs","event","regionElement","eventType","touches","pointerType","Array","from","changedTouches","forEach","touch","update","identifier","pointerId","state","normalizeEvent","type","findInputById","resetInputs","current","numActiveInputs","endType","length","key","setId","find","i"],"sources":["State.js"],"sourcesContent":["/**\n * @file State.js\n */\nimport Gesture from './../../gestures/Gesture.js';\nimport Pan from './../../gestures/Pan.js';\nimport Distance from './../../gestures/Distance.js';\nimport Rotate from './../../gestures/Rotate.js';\nimport Swipe from './../../gestures/Swipe.js';\nimport Tap from './../../gestures/Tap.js';\nimport Binding from './Binding.js';\nimport Input from './Input.js';\nimport util from './../util.js';\nconst DEFAULT_MOUSE_ID = 0;\n/**\n * Creates an object related to a Region's state,\n * and contains helper methods to update and clean up different states.\n */\nclass State {\n    /**\n     * Constructor for the State class.\n     * @param {String} regionId - The id the region this state is bound to.\n     */\n    constructor(regionId) {\n        /**\n         * The id for the region this state is bound to.\n         * @type {String}\n         */\n        this.regionId = regionId;\n        /**\n         * An array of current and recently inactive\n         *  Input objects related to a gesture.\n         * @type {Input}\n         */\n        this.inputs = [];\n        /**\n         * An array of Binding objects; The list of relations between elements,\n         *   their gestures, and the handlers.\n         * @type {Binding}\n         */\n        this.bindings = [];\n        /**\n         * The number of gestures that have been registered with this state\n         * @type {Number}\n         */\n        this.numGestures = 0;\n        /**\n         * A key/value map all the registered gestures for the listener.\n         *  Note: Can only have one gesture registered to one key.\n         * @type {Object}\n         */\n        this.registeredGestures = {};\n        this.registerGesture(new Pan(), 'pan');\n        this.registerGesture(new Rotate(), 'rotate');\n        this.registerGesture(new Distance(), 'distance');\n        this.registerGesture(new Swipe(), 'swipe');\n        this.registerGesture(new Tap(), 'tap');\n    }\n    /**\n     * Creates a new binding with the given element and gesture object.\n     * If the gesture object provided is unregistered, it's reference\n     * will be saved in as a binding to be later referenced.\n     * @param  {Element} element - The element the gesture is bound to.\n     * @param {String|Object} gesture  - Either a name of a registered gesture,\n     *  or an unregistered  Gesture object.\n     * @param {Function} handler - The function handler to be called\n     *  when the event is emitted. Used to bind/unbind.\n     * @param {Boolean} capture - Whether the gesture is to be\n     *  detected in the capture of bubble phase. Used to bind/unbind.\n     * @param {Boolean} bindOnce - Option to bind once and\n     *  only emit the event once.\n     */\n    addBinding(element, gesture, handler, capture, bindOnce) {\n        let boundGesture;\n        // Error type checking.\n        if (element && typeof element.tagName === 'undefined') {\n            throw new Error('Parameter element is an invalid object.');\n        }\n        if (typeof handler !== 'function') {\n            throw new Error('Parameter handler is invalid.');\n        }\n        if (typeof gesture === 'string' &&\n            Object.keys(this.registeredGestures).indexOf(gesture) === -1) {\n            throw new Error('Parameter ' + gesture + ' is not a registered gesture');\n        }\n        else if (typeof gesture === 'object' && !(gesture instanceof Gesture)) {\n            throw new Error('Parameter for the gesture is not of a Gesture type');\n        }\n        if (typeof gesture === 'string') {\n            boundGesture = this.registeredGestures[gesture];\n        }\n        else {\n            boundGesture = gesture;\n            if (boundGesture.id === '') {\n                this.assignGestureId(boundGesture);\n            }\n        }\n        this.bindings.push(new Binding(element, boundGesture, handler, capture, bindOnce));\n        element.addEventListener(boundGesture.getId(), handler, capture);\n    }\n    /**\n     * Retrieves the Binding by which an element is associated to.\n     * @param {Element} element - The element to find bindings to.\n     * @return {Array} - An array of Bindings to which that element is bound\n     */\n    retrieveBindingsByElement(element) {\n        return this.bindings.filter(b => b.element === element);\n    }\n    /**\n     * Retrieves all bindings based upon the initial X/Y position of the inputs.\n     * e.g. if gesture started on the correct target element,\n     *  but diverted away into the correct region, this would still be valid.\n     * @return {Array} - An array of Bindings to which that element is bound\n     */\n    retrieveBindingsByInitialPos() {\n        return this.bindings.filter(binding => {\n            return this.inputs.some(input => {\n                return util.isInside(input.initial.x, input.initial.y, binding.element);\n            });\n        });\n    }\n    /**\n     * Updates the inputs with new information based upon a new event being fired.\n     * @param {Event} event - The event being captured.\n     * @param {Element} regionElement - The element where\n     *  this current Region is bound to.\n     * @return {boolean} - returns true for a successful update,\n     *  false if the event is invalid.\n     */\n    updateInputs(event, regionElement) {\n        let eventType = (event.touches) ?\n            'TouchEvent' : ((event.pointerType) ? 'PointerEvent' : 'MouseEvent');\n        switch (eventType) {\n            case 'TouchEvent':\n                Array.from(event.changedTouches).forEach(touch => {\n                    update(event, this, touch.identifier, regionElement);\n                });\n                break;\n            case 'PointerEvent':\n                update(event, this, event.pointerId, regionElement);\n                break;\n            case 'MouseEvent':\n            default:\n                update(event, this, DEFAULT_MOUSE_ID, regionElement);\n                break;\n        }\n        return true;\n        function update(event, state, identifier, regionElement) {\n            const eventType = util.normalizeEvent[event.type];\n            const input = findInputById(state.inputs, identifier);\n            // A starting input was not cleaned up properly and still exists.\n            if (eventType === 'start' && input) {\n                state.resetInputs();\n                return;\n            }\n            // An input has moved outside the region.\n            if (eventType !== 'start' &&\n                input &&\n                !util.isInside(input.current.x, input.current.y, regionElement)) {\n                state.resetInputs();\n                return;\n            }\n            if (eventType !== 'start' && !input) {\n                state.resetInputs();\n                return;\n            }\n            if (eventType === 'start') {\n                state.inputs.push(new Input(event, identifier));\n            }\n            else {\n                input.update(event, identifier);\n            }\n        }\n    }\n    /**\n     * Removes all inputs from the state, allowing for a new gesture.\n     */\n    resetInputs() {\n        this.inputs = [];\n    }\n    /**\n     * Counts the number of active inputs at any given time.\n     * @return {Number} - The number of active inputs.\n     */\n    numActiveInputs() {\n        const endType = this.inputs.filter((input) => {\n            return input.current.type !== 'end';\n        });\n        return endType.length;\n    }\n    /**\n     * Register the gesture to the current region.\n     * @param {Object} gesture - The gesture to register\n     * @param {String} key - The key to define the new gesture as.\n     */\n    registerGesture(gesture, key) {\n        this.assignGestureId(gesture);\n        this.registeredGestures[key] = gesture;\n    }\n    /**\n     * Tracks the gesture to this state object to become uniquely identifiable.\n     * Useful for nested Regions.\n     * @param {Gesture} gesture - The gesture to track\n     */\n    assignGestureId(gesture) {\n        gesture.setId(this.regionId + '-' + this.numGestures++);\n    }\n}\n/**\n * Searches through each input, comparing the browser's identifier key\n *  for touches, to the stored one in each input\n * @param {Array} inputs - The array of inputs in state.\n * @param {String} identifier - The identifier the browser has assigned.\n * @return {Input} - The input object with the corresponding identifier,\n *  null if it did not find any.\n */\nfunction findInputById(inputs, identifier) {\n    return inputs.find(i => i.identifier === identifier);\n}\nexport default State;\n"],"mappings":"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","ignoreList":[]}