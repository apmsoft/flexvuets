{"version":3,"file":"arbiter.js","names":["dispatcher","interpreter","util","arbiter","event","region","state","eventType","normalizeEvent","type","inputs","length","buttons","resetInputs","updateInputs","element","bindings","retrieveBindingsByInitialPos","preventDefault","setMSPreventDefault","removeMSPreventDefault","toBeDispatched","gestures","path","getPropagationPath","forEach","gesture","id","binding","getId","getPathIndex","Object","keys","index","data","events","endCount","input","getCurrentEventType"],"sources":["arbiter.js"],"sourcesContent":["/**\n * @file arbiter.js\n * Contains logic for the dispatcher\n */\nimport dispatcher from './dispatcher.js';\nimport interpreter from './interpreter.js';\nimport util from './util.js';\n/**\n * Function that handles event flow, negotiating with the interpreter,\n * and dispatcher.\n * 1. Receiving all touch events in the window.\n * 2. Determining which gestures are linked to the target element.\n * 3. Negotiating with the Interpreter what event should occur.\n * 4. Sending events to the dispatcher to emit events to the target.\n * @param {Event} event - The event emitted from the window object.\n * @param {Object} region - The region object of the current listener.\n */\nfunction arbiter(event, region) {\n    const state = region.state;\n    const eventType = util.normalizeEvent[event.type];\n    /*\n     Return if a gesture is not in progress and won't be. Also catches the case\n     where a previous event is in a partial state (2 finger pan, waits for both\n     inputs to reach touchend)\n     */\n    if (state.inputs.length === 0 && eventType !== 'start') {\n        return;\n    }\n    /*\n     Check for 'stale' or events that lost focus\n     (e.g. a pan goes off screen/off region.)\n     Does not affect mobile devices.\n     */\n    if (typeof event.buttons !== 'undefined' &&\n        eventType !== 'end' &&\n        event.buttons === 0) {\n        state.resetInputs();\n        return;\n    }\n    // Update the state with the new events. If the event is stopped, return;\n    if (!state.updateInputs(event, region.element)) {\n        return;\n    }\n    // Retrieve the initial target from any one of the inputs\n    const bindings = state.retrieveBindingsByInitialPos();\n    if (bindings.length > 0) {\n        if (region.preventDefault) {\n            util.setMSPreventDefault(region.element);\n            util.preventDefault(event);\n        }\n        else {\n            util.removeMSPreventDefault(region.element);\n        }\n        const toBeDispatched = {};\n        const gestures = interpreter(bindings, event, state);\n        /* Determine the deepest path index to emit the event\n         from, to avoid duplicate events being fired. */\n        const path = util.getPropagationPath(event);\n        gestures.forEach((gesture) => {\n            const id = gesture.binding.gesture.getId();\n            if (toBeDispatched[id]) {\n                if (util.getPathIndex(path, gesture.binding.element) <\n                    util.getPathIndex(path, toBeDispatched[id].binding.element)) {\n                    toBeDispatched[id] = gesture;\n                }\n            }\n            else {\n                toBeDispatched[id] = gesture;\n            }\n        });\n        Object.keys(toBeDispatched).forEach((index) => {\n            const gesture = toBeDispatched[index];\n            dispatcher(gesture.binding, gesture.data, gesture.events);\n        });\n    }\n    let endCount = 0;\n    state.inputs.forEach((input) => {\n        if (input.getCurrentEventType() === 'end') {\n            endCount++;\n        }\n    });\n    if (endCount === state.inputs.length) {\n        state.resetInputs();\n    }\n}\nexport default arbiter;\n"],"mappings":"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","ignoreList":[]}